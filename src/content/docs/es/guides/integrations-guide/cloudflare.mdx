---
type: integration
title: '@astrojs/cloudflare'
description: Aprende cómo usar el adaptador @astrojs/cloudflare para desplegar tu proyecto Astro.
sidebar:
  label: Cloudflare
githubIntegrationURL: 'https://github.com/withastro/astro/tree/main/packages/integrations/cloudflare/'
category: adapter
i18nReady: true
---

import PackageManagerTabs from '~/components/tabs/PackageManagerTabs.astro'
import ReadMore from '~/components/ReadMore.astro';
import Since from '~/components/Since.astro';
import { Tabs, TabItem, Steps } from '@astrojs/starlight/components';


Este adaptador permite a Astro desplegar tus [rutas y características renderizadas bajo demanda](/es/guides/on-demand-rendering/) en [Cloudflare](https://www.cloudflare.com/), incluyendo [islas de servidor](/es/guides/server-islands/), [acciones](/es/guides/actions/), y [sesiones](/es/guides/sessions/).

Si estás usando Astro como generador de sitios estáticos, no necesitas un adaptador.

Aprende cómo desplegar tu sitio Astro en nuestra [guía de despliegue en Cloudflare](/es/guides/deploy/cloudflare/).

## Por qué Astro Cloudflare

La [Plataforma de Desarrolladores](https://developers.cloudflare.com/) de Cloudflare te permite desarrollar aplicaciones full-stack con acceso a recursos como almacenamiento e IA, todo desplegado en una red global edge. Este adaptador construye tu proyecto Astro para el despliegue a través de Cloudflare.


## Instalación

Astro incluye un comando `astro add` para automatizar la configuración de integraciones oficiales. Si prefieres, puedes [instalar integraciones manualmente](#instalación-manual) en su lugar.

Agrega el adaptador de Cloudflare para habilitar la renderización del servidor en tu proyecto Astro con el comando `astro add`. Esto instalará `@astrojs/cloudflare` y hará los cambios apropiados a tu archivo `astro.config.mjs` en un paso.

<PackageManagerTabs>
  <Fragment slot="npm">
  ```sh
  npx astro add cloudflare
  ```
  </Fragment>
  <Fragment slot="pnpm">
  ```sh
  pnpm astro add cloudflare
  ```
  </Fragment>
  <Fragment slot="yarn">
  ```sh
  yarn astro add cloudflare
  ```
  </Fragment>
</PackageManagerTabs>

Ahora, puedes habilitar [la renderización bajo demanda por página](/es/guides/on-demand-rendering/#habilitar-el-renderizado-bajo-demanda), o configurar tu configuración de salida de construcción a `output: 'server'` para [renderizar en el servidor todas tus páginas por defecto](/es/guides/on-demand-rendering/#modo-server).

### Instalación Manual

Primero, agrega el adaptador `@astrojs/cloudflare` a las dependencias de tu proyecto usando tu gestor de paquetes preferido.

<PackageManagerTabs>
  <Fragment slot="npm">
  ```sh
  npm install @astrojs/cloudflare
  ```
  </Fragment>
  <Fragment slot="pnpm">
  ```sh
  pnpm add @astrojs/cloudflare
  ```
  </Fragment>
  <Fragment slot="yarn">
  ```sh
  yarn add @astrojs/cloudflare
  ```
  </Fragment>
</PackageManagerTabs>

Luego, agrega el adaptador a tu archivo `astro.config.mjs`:

```js title="astro.config.mjs" ins={2,5}
import { defineConfig } from 'astro/config';
import cloudflare from '@astrojs/cloudflare';

export default defineConfig({
  adapter: cloudflare(),
});
```

## Opciones

El adaptador de Cloudflare acepta las siguientes opciones:

### `cloudflareModules`

<p>
**Tipo:** `boolean`<br />
**Por defecto:** `true`
</p>

Habilita [importaciones de módulos `.wasm`, `.bin`, y `.txt`](#importaciones-de-módulos-de-cloudflare).

Esta funcionalidad está habilitada por defecto. Si deseas deshabilitarla, establece `cloudflareModules` en `false`.

### `imageService`

<p>
**Tipo:** `'passthrough' | 'cloudflare' | 'compile' | 'custom'`<br />
**Por defecto:** `'compile'`
</p>

Determina qué servicio de imágenes es usado por el adaptador. El adaptador utilizará por defecto el modo `compile` cuando se configure un servicio de imágenes incompatible. De lo contrario, usará el servicio de imágenes configurado globalmente:

* **`cloudflare`:** Usa el servicio [Cloudflare Image Resizing](https://developers.cloudflare.com/images/image-resizing/).
* **`passthrough`:** Usa el servicio [`noop`](/es/guides/images/#configura-el-servicio-no-op-de-paso) existente.
* **`compile`:** Usa el servicio por defecto de Astro (sharp), pero solo en rutas pre-renderizadas en tiempo de construcción. Para páginas renderizadas bajo demanda, todas las características de `astro:assets` están deshabilitadas.
* **`custom`:** Siempre usa el servicio de imágenes configurado en [Opciones de Imagen](/es/reference/configuration-reference/#opciones-de-imagen). **Esta opción no verificará si el servicio de imágenes configurado funciona en el runtime `workerd` de Cloudflare.**

```js title="astro.config.mjs" ins={6}
import { defineConfig } from "astro/config";
import cloudflare from '@astrojs/cloudflare';

export default defineConfig({
  adapter: cloudflare({
     imageService: 'cloudflare'
  }),
})
```

### `platformProxy`

Determina si y cómo se añade el runtime de Cloudflare a `astro dev`. Contiene proxies a enlaces `workerd` locales y emulaciones de valores específicos de Cloudflare, permitiendo la emulación del runtime en el proceso de desarrollo de Node.js. Lee más sobre el [Runtime de Cloudflare](#runtime-de-cloudflare).

:::note
Los proxies proporcionados por esto son una emulación de mejor esfuerzo de la producción real. Aunque están diseñados para ser lo más cercanos posible a lo real, puede haber ligeras diferencias e inconsistencias entre los dos.
:::

#### `platformProxy.enabled`
<p>
**Tipo:** `boolean`<br />
**Por defecto:** `true`
</p>

Determina si habilitar el runtime de Cloudflare en modo de desarrollo.

#### `platformProxy.configPath`
<p>
**Tipo:** `string`<br />
**Por defecto:** `undefined`
</p>

Define la ruta al archivo de configuración de Wrangler. Si no se establece un valor, rastrea `wrangler.toml`, `wrangler.json`, y `wrangler.jsonc` en la raíz del proyecto.

#### `platformProxy.environment`
<p>
**Tipo:** `string`<br />
**Por defecto:** `undefined`
</p>

Establece el [entorno de Cloudflare](https://developers.cloudflare.com/workers/wrangler/environments/) a usar. Debes seleccionar un entorno definido en el archivo de configuración de Wrangler, de lo contrario ocurrirá un error.

#### `platformProxy.persist`
<p>
**Tipo:** `boolean | { path: string }`<br />
**Por defecto:** `true`
</p>

Establece si y dónde guardar los datos de enlace localmente en el sistema de archivos.

- Si se establece en `true`, los datos de enlace se almacenan en `.wrangler/state/v3/`. Es el mismo que la configuración por defecto para wrangler.
- Si se establece en `false`, los datos de enlace no se almacenan en el sistema de archivos.
- Si se establece en `{ path: string }`, los datos de enlace se almacenan en la ruta especificada.

:::note
La opción `--persist-to` de `wrangler` añade un subdirectorio llamado `v3` internamente mientras que la propiedad `persist` de `@astrojs/cloudflare` no lo hace. Por ejemplo, para reutilizar la misma ubicación que ejecutar `wrangler dev --persist-to ./my-directory`, debes especificar: `persist: { path: "./my-directory/v3" }`.
:::

La siguiente configuración muestra un ejemplo de habilitar el runtime de Cloudflare al ejecutar el servidor de desarrollo, así como usar un archivo de configuración `wrangler.json`. También especifica una ubicación personalizada para persistir datos en el sistema de archivos:


```js
import cloudflare from '@astrojs/cloudflare';
import { defineConfig } from 'astro/config';

export default defineConfig({
	adapter: cloudflare({
		platformProxy: {
			enabled: true,
			configPath: 'wrangler.json',
			persist: {
				path: './.cache/wrangler/v3'
			},
		},
	}),
});
```
### `routes.extend`

En Cloudflare Workers, esta opción no es aplicable. Consulta [Enrutamiento en Cloudflare Workers](#enrutamiento-en-cloudflare-workers) para más información.

En Cloudflare Pages, esta opción te permite agregar o excluir patrones personalizados (ej. `/fonts/*`) al archivo `_routes.json` generado que determina qué rutas se generan bajo demanda. Esto puede ser útil si necesitas agregar patrones de ruta que no pueden ser generados automáticamente, o excluir rutas pre-renderizadas.

Más información sobre los patrones de ruta personalizados se puede encontrar en [la documentación de enrutamiento de Cloudflare](https://developers.cloudflare.com/pages/functions/routing/#functions-invocation-routes). Cualquier ruta especificada no se deduplica automáticamente y se añadirá a las rutas existentes tal como está.

#### `routes.extend.include`

<p>
**Tipo:** `{ pattern: string }[]`<br />
**Por defecto:** `undefined`
</p>

Configura rutas adicionales para ser generadas bajo demanda por el adaptador de Cloudflare en el array `routes.extend.include`.

#### `routes.extend.exclude`

<p>
**Tipo:** `{ pattern: string }[]`<br />
**Por defecto:** `undefined`
</p>

Configura rutas para ser excluidas de la renderización bajo demanda en el array `routes.extend.exclude`. Estas rutas serán pre-renderizadas y servidas estáticamente en su lugar, y no invocarán la función del servidor. Adicionalmente puedes usar esta opción para servir cualquier archivo de activo estático (ej. imágenes, fuentes, css, js, html, txt, json, etc.) directamente sin enrutar la solicitud a través de la función del servidor.

```js title="astro.config.mjs"
export default defineConfig({
  adapter: cloudflare({
    routes: {
      extend: {
        include: [{ pattern: '/static' }], // Route a prerended page to the server function for on-demand rendering
        exclude: [{ pattern: '/pagefind/*' }], // Use Starlight's pagefind search, which is generated statically at build time
      }
    },
  }),
});
```

### `sessionKVBindingName`
<p>
**Tipo:** `string`<br />
**Por defecto:** `SESSION`
<Since v="5.6.0" />
</p>

La opción `sessionKVBindingName` te permite especificar el nombre del enlace KV usado para el almacenamiento de sesiones. Por defecto, esto está establecido en `SESSION`, pero puedes cambiarlo para que coincida con tu propio nombre de enlace KV. Consulta [Sesiones](#sesiones) para más información.

```js title="astro.config.mjs" "MY_SESSION_BINDING"
export default defineConfig({
  adapter: cloudflare({
    sessionKVBindingName: 'MY_SESSION_BINDING',
  }),
});
```

### `workerEntryPoint`
<p>

**Tipo:** `{ path: string | URL, namedExports: string[] }`<br />
**Por defecto:** `{ path: '@astrojs/cloudflare/entrypoints/server.js', namedExports: [] }`<br />
<Since v="12.6.0" pkg="@astrojs/cloudflare"/>
</p>


Un objeto de configuración para especificar el [workerEntryPoint](https://developers.cloudflare.com/workers/runtime-apis/bindings/service-bindings/rpc/) para tu Cloudflare Worker cuando usas el comando `astro build`.

Te permite especificar opcionalmente tanto una `ruta` de archivo personalizada como `namedExports`:

```js title="astro.config.mjs"
import cloudflare from '@astrojs/cloudflare';
import { defineConfig } from 'astro/config';

export default defineConfig({
	adapter: cloudflare({
		workerEntryPoint: {
			path: 'src/worker.ts',
			namedExports: ['MyDurableObject']
		}
	}),
});
```

#### `workerEntryPoint.path`

<p>

**Tipo:** `string`<br />
**Por defecto:** `@astrojs/cloudflare/entrypoints/server.js`
<Since v="12.6.0" pkg="@astrojs/cloudflare" />
</p>

La ruta al archivo de entrada. Esta debe ser una ruta relativa desde la raíz de tu proyecto Astro.

Por defecto, el adaptador usa un archivo de entrada genérico, que solo soporta el manejador `fetch`.

Para soportar otros [manejadores de invocación de Cloudflare](https://developers.cloudflare.com/workers/observability/logs/workers-logs/#invocation-logs), puedes crear un archivo personalizado para usar como punto de entrada. Esto es útil si quieres usar características que requieren otros manejadores (ej. Durable Objects, Cloudflare Queues, Invocaciones Programadas).

#### `workerEntryPoint.namedExports` 

<p>

**Tipo:** `[]`<br />
**Por defecto:** `['default']`
<Since v="12.6.0" pkg="@astrojs/cloudflare" />
</p>

Un array de exportaciones nombradas para usar en el archivo de entrada.

Proporciona cualquier exportación nombrada adicional definida de tu [archivo de entrada personalizado](#creando-un-archivo-de-entrada-personalizado-de-cloudflare-worker) (ej. `DurableObject`). Si no se proporciona, solo se incluirán las exportaciones por defecto.

#### Creando un archivo de entrada personalizado de Cloudflare Worker

El archivo de entrada personalizado debe exportar la función `createExports()` con una exportación `default` incluyendo todos los manejadores que necesites.

El siguiente archivo de entrada de ejemplo registra un Durable Object y un manejador de cola:

```ts title="src/worker.ts"
import type { SSRManifest } from 'astro';
import { App } from 'astro/app';
import { handle } from '@astrojs/cloudflare/handler'
import { DurableObject } from 'cloudflare:workers';

class MyDurableObject extends DurableObject<Env> {
  constructor(ctx: DurableObjectState, env: Env) {
    super(ctx, env)
  }
}

export function createExports(manifest: SSRManifest) {
	const app = new App(manifest);
	return {
		default: {
			async fetch(request, env, ctx) {
				await env.MY_QUEUE.send("log");
				return handle(manifest, app, request, env, ctx);
			},
			async queue(batch, _env) {
				let messages = JSON.stringify(batch.messages);
				console.log(`consumed from our queue: ${messages}`);
			}
		} satisfies ExportedHandler<Env>,
		MyDurableObject: MyDurableObject,
	}
}
```

## Runtime de Cloudflare

### Uso

El runtime de Cloudflare te da acceso a variables de entorno y enlaces a recursos de Cloudflare.
El runtime de Cloudflare usa enlaces encontrados en el archivo de configuración `wrangler.toml`/`wrangler.json`. 

Puedes acceder a los enlaces desde `Astro.locals.runtime`:

```astro title="src/pages/index.astro"
---
const { env } = Astro.locals.runtime;
---
```
Puedes acceder al runtime desde endpoints de API a través de `context.locals`:

```js title="src/pages/api/someFile.js"
export function GET(context) {
  const runtime = context.locals.runtime;

  return new Response('Some body');
}
```

Consulta la [lista de todos los enlaces soportados](https://developers.cloudflare.com/workers/wrangler/api/#supported-bindings) en la documentación de Cloudflare.


### Variables de entorno y secretos

El runtime de Cloudflare trata las variables de entorno como un tipo de enlace.

Por ejemplo, puedes definir una [variable de entorno](https://developers.cloudflare.com/workers/configuration/environment-variables/#add-environment-variables-via-wrangler) en `wrangler.json` de la siguiente manera:

```json title="wrangler.json"
{
  "vars" : {
    "MY_VARIABLE": "test"
  }
}
```

Los secretos son un tipo especial de variable de entorno que te permite adjuntar valores de texto encriptados a tu Worker. Necesitan ser definidos de manera diferente para asegurar que no sean visibles después de que los configures.

Para definir `secrets`, añádelos a través del [Wrangler CLI](https://developers.cloudflare.com/workers/wrangler/) en lugar de en tu archivo de configuración de Wrangler. 

```bash
npx wrangler secret put <KEY>
```

Para configurar secretos para desarrollo local, también necesitas agregar un archivo `.dev.vars` a la raíz del proyecto Astro:

```ini title=".dev.vars"
DB_PASSWORD=myPassword
```

Entonces puedes acceder a variables de entorno, incluyendo secretos, desde el objeto `env` disponible desde `Astro.locals.runtime`:  

```astro title="src/pages/index.astro"
---
const { env } = Astro.locals.runtime;
const myVariable = env.MY_VARIABLE;
const secret = env.DB_PASSWORD;
---
```

{/*TODO: add link to /en/guides/environment-variables/#type-safe-environment-variables*/}
Las variables de entorno y secretos de Cloudflare son compatibles con la API `astro:env`).

### Tipado

`wrangler` proporciona un comando `types` para generar tipos de TypeScript para los enlaces. Esto te permite tipar locals sin la necesidad de tiparlos manualmente. Consulta la [documentación de Cloudflare](https://developers.cloudflare.com/workers/wrangler/commands/#types) para más información.

Cada vez que cambies tus archivos de configuración (ej. `wrangler.toml`, `.dev.vars`) necesitas ejecutar `wrangler types`.

:::note
Puedes crear un script de pnpm para ejecutar `wrangler types` automáticamente antes de otros comandos.

```json title="package.json"
{
  "scripts": {
    "dev": "wrangler types && astro dev",
    "start": "wrangler types && astro dev",
    "build": "wrangler types && astro check && astro build",
    "preview": "wrangler types && astro preview",
    "astro": "astro"
  }
}
```
:::

Puedes tipar el objeto `runtime` usando `Runtime`:

```ts title="src/env.d.ts"
type Runtime = import('@astrojs/cloudflare').Runtime<Env>;

declare namespace App {
  interface Locals extends Runtime {
    otherLocals: {
      test: string;
    };
  }
}
```

## Plataforma Cloudflare

### Headers

Puedes adjuntar [headers personalizados](https://developers.cloudflare.com/pages/platform/headers/) a tus respuestas agregando un archivo `_headers` en la carpeta `public/` de tu proyecto Astro. Este archivo será copiado al directorio de salida de construcción.

Esto está disponible en Cloudflare Workers y Pages.

### Assets
Los assets construidos por Astro tienen nombres con un hash y por lo tanto se les pueden otorgar headers de caché largos. Por defecto, Astro en Cloudflare agregará tal header para estos archivos.

### Redirecciones

Puedes declarar [redirecciones personalizadas](https://developers.cloudflare.com/pages/platform/redirects/) para redireccionar solicitudes a una URL diferente. Para hacer esto, agrega un archivo `_redirects` en la carpeta `public/` de tu proyecto Astro. Este archivo será copiado al directorio de salida de construcción.

Esto está disponible en Cloudflare Workers y Pages.

### Rutas
#### Enrutamiento en Cloudflare Workers

El enrutamiento para assets estáticos se basa en la estructura de archivos en el directorio de construcción (ej. `./dist`). Si no se encuentra una coincidencia, esto se delegará al Worker para renderización bajo demanda. Lee más sobre [enrutamiento de assets estáticos con Cloudflare Workers](https://developers.cloudflare.com/workers/static-assets/routing/).

A diferencia de [Cloudflare Pages](#enrutamiento-en-cloudflare-pages), con Workers, no necesitas un archivo `_routes.json`.

Actualmente, el adaptador de Cloudflare siempre genera este archivo. Para evitar esto, crea un archivo `.assetsignore` en tu carpeta `public/`, y agrega las siguientes líneas:
  ```txt title="public/.assetsignore"
  _worker.js
  _routes.json
  ```

#### Enrutamiento en Cloudflare Pages

Para Cloudflare Pages, [el enrutamiento](https://developers.cloudflare.com/pages/platform/functions/routing/#functions-invocation-routes) usa un archivo `_routes.json` para determinar qué solicitudes se enrutan a la función del servidor y cuáles se sirven como assets estáticos. Por defecto, un archivo `_routes.json` será generado automáticamente para tu proyecto basado en sus archivos y configuración.

Puedes [especificar patrones de enrutamiento adicionales a seguir](#routesextend) en tu configuración del adaptador, o crear tu propio archivo `_routes.json` personalizado para anular completamente la generación automática.


Crear un `public/_routes.json` personalizado anulará la generación automática. Consulta [la documentación de Cloudflare sobre crear un `_routes.json` personalizado](https://developers.cloudflare.com/pages/platform/functions/routing/#create-a-_routesjson-file) para más detalles.

## Sesiones

La [API de Sesiones](/es/guides/sessions/) de Astro te permite almacenar fácilmente datos de usuario entre solicitudes. Esto puede ser usado para cosas como datos de usuario y preferencias, carritos de compras, y credenciales de autenticación. A diferencia del almacenamiento en cookies, no hay límites de tamaño en los datos, y puede ser restaurado en diferentes dispositivos.

Astro configura automáticamente [Workers KV](https://developers.cloudflare.com/kv/) para el almacenamiento de sesiones cuando usa el adaptador de Cloudflare. Antes de usar sesiones, necesitas crear un namespace KV para almacenar los datos y configurar un enlace KV en tu archivo de configuración de Wrangler. Por defecto, Astro espera que el enlace KV se llame `SESSION`, pero puedes elegir un nombre diferente si prefieres estableciendo la opción [`sessionKVBindingName`](#sessionkvbindingname) en la configuración del adaptador.

<Steps>

1. Crea un namespace KV usando el CLI de Wrangler y toma nota del ID del nuevo namespace:

   ```sh
   npx wrangler kv namespace create "SESSION"
   ```

2. Declara el namespace KV en tu configuración de Wrangler, estableciendo el ID del namespace al devuelto por el comando anterior:

    <Tabs>
      <TabItem label="wrangler.json">
        ```json title="wrangler.json" "<KV_NAMESPACE_ID>"
        {
          "kv_namespaces": [
            {
              "binding": "SESSION",
              "id": "<KV_NAMESPACE_ID>"
            }
          ]
        }
        ```
      </TabItem>
      <TabItem label="wrangler.toml">
        ```toml title="wrangler.toml" "<KV_NAMESPACE_ID>"
        kv_namespaces = [
          { binding = "SESSION", id = "<KV_NAMESPACE_ID>" }
        ]
        ```
      </TabItem>
    </Tabs>

3. Entonces puedes usar sesiones en tu código del servidor:

    ```astro title="src/components/CartButton.astro" "Astro.session?.get('cart')"
    ---
    export const prerender = false;
    const cart = await Astro.session?.get('cart');
    ---

    <a href="/checkout">🛒 {cart?.length ?? 0} items</a>
    ```

</Steps>

:::note
Las escrituras a Cloudflare KV son [eventualmente consistentes](https://developers.cloudflare.com/kv/concepts/how-kv-works/#consistency) entre regiones. Esto significa que los cambios están disponibles inmediatamente dentro de la misma región pero pueden tomar hasta 60 segundos para propagarse globalmente. Esto no afectará a la mayoría de usuarios ya que es poco probable que cambien de región entre solicitudes, pero puede ser una consideración para algunos casos de uso, como usuarios de VPN.
:::


## Importaciones de Módulos de Cloudflare

El runtime `workerd` de Cloudflare soporta importaciones de algunos [tipos de módulos no estándar](https://developers.cloudflare.com/workers/wrangler/bundling/#including-non-javascript-modules). La mayoría de tipos de archivos adicionales también están disponibles en Astro:

- `.wasm` o `.wasm?module`: exporta un [`WebAssembly.Module`](https://developer.mozilla.org/en-US/docs/WebAssembly/JavaScript_interface/Module) que puede ser instanciado
- `.bin`: exporta un [`ArrayBuffer`](https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) del contenido binario crudo del archivo
- `.txt`: exporta una cadena del contenido del archivo

Todos los tipos de módulos exportan un único valor por defecto. Los módulos pueden ser importados tanto desde páginas renderizadas del lado del servidor, como desde páginas pre-renderizadas para generación de sitios estáticos.

Lo siguiente es un ejemplo de importar un módulo Wasm que luego responde a solicitudes sumando los parámetros numéricos de la solicitud.

```js title="pages/add/[a]/[b].js"
// Importando el módulo WebAssembly
import mod from '../util/add.wasm';

// Instanciar primero para poder usarlo
const addModule: any = new WebAssembly.Instance(mod);

export async function GET(context) {
  const a = Number.parseInt(context.params.a);
  const b = Number.parseInt(context.params.b);
  return new Response(`${addModule.exports.add(a, b)}`);
}
```

Aunque este ejemplo es trivial, Wasm puede ser usado para acelerar operaciones computacionalmente intensivas que no involucran I/O significativo como incrustar una biblioteca de procesamiento de imágenes, o incrustar una pequeña base de datos pre-indexada para búsqueda sobre un conjunto de datos de solo lectura.

## Compatibilidad con Node.js

Por defecto, Cloudflare no soporta las APIs del runtime de Node.js. Con algo de configuración, Cloudflare sí soporta un subconjunto de las APIs del runtime de Node.js. Puedes encontrar las APIs del runtime de Node.js soportadas en la [documentación](https://developers.cloudflare.com/workers/runtime-apis/nodejs) de Cloudflare.

Para usar estas APIs, tu página o endpoint debe ser renderizado del lado del servidor (no pre-renderizado) y debe usar la sintaxis de importación `import {} from 'node:*'`.

```js title="pages/api/endpoint.js"
export const prerender = false;
import { Buffer } from 'node:buffer';
```

También necesitarás modificar la configuración de `vite` en tu configuración de Astro para permitir la sintaxis de importación `node:*`:

```js title="astro.config.mjs" ins={6-10}
import {defineConfig} from "astro/config";
import cloudflare from '@astrojs/cloudflare';

export default defineConfig({
  adapter: cloudflare({}),
  vite: {
		ssr: {
			external: ['node:buffer'],
		},
	},
})
```

Adicionalmente, necesitarás seguir la documentación de Cloudflare sobre cómo habilitar el soporte. Para una guía detallada, por favor consulta la [documentación de Cloudflare sobre habilitar la compatibilidad con Node.js](https://developers.cloudflare.com/workers/runtime-apis/nodejs/).

:::note[Implicaciones de Compatibilidad de Paquetes]
Si un proyecto importa un paquete al servidor que usa las APIs del runtime de Node.js, esto puede causar problemas al desplegar en Cloudflare. Este problema surge con paquetes que no usan la sintaxis de importación `node:*`. Se recomienda que contactes a los autores del paquete para determinar si el paquete soporta la sintaxis de importación mencionada. Si el paquete no soporta esto, puede que necesites usar un paquete diferente.
:::

## Vista previa con Wrangler

Para usar [`wrangler`](https://developers.cloudflare.com/workers/wrangler/) para ejecutar tu aplicación localmente, actualiza el script de vista previa.

Para Workers:

```json title="package.json"
"preview": "wrangler dev ./dist"
```

Para Pages:

```json title="package.json"
"preview": "wrangler pages dev ./dist"
```

Desarrollar con [`wrangler`](https://developers.cloudflare.com/workers/wrangler/) te da acceso a [enlaces de Cloudflare](https://developers.cloudflare.com/pages/platform/functions/bindings), [variables de entorno](https://developers.cloudflare.com/pages/platform/functions/bindings/#environment-variables), y el [objeto cf](https://developers.cloudflare.com/workers/runtime-apis/request/#incomingrequestcfproperties). Hacer que la recarga en caliente del servidor de desarrollo de Astro funcione con Wrangler podría requerir una configuración personalizada. Consulta [ejemplos de la comunidad](https://github.com/withastro/roadmap/discussions/590).

### Mensajes de error significativos

Actualmente, los errores durante la ejecución de tu aplicación en Wrangler no son muy útiles, debido a la minificación de tu código. Para una mejor depuración, puedes agregar la configuración `vite.build.minify = false` a tu `astro.config.mjs`.

```js title="astro.config.mjs" ins={3-7}
export default defineConfig({
  adapter: cloudflare(),
  vite: {
    build: {
      minify: false,
    },
  },
});
```

[astro-integration]: /es/guides/integrations-guide/
